[
  {
    "name": "Localized",
    "comment": " Create localized texts in a type safe way. You can put all your\ntranslations in a module (say `Translations.En`) which then looks like\nthis:\n\n    import Localized exposing (Translation, concat, equals, final, s, select, string)\n    import Localized.En exposing (cardinal, decimalStandard)\n\n    greeting : Translation args msg\n    greeting =\n        final \"greeting\" <|\n            s \"Good morning!\"\n\n    personalGreeting : Translation { args | name : String } msg\n    personalGreeting =\n        final \"personalGreeting\" <|\n            concat\n                [ s \"Good morning, \"\n                , string .name \"name\"\n                , s \"!\"\n                ]\n\n    emailInfo : Translation { args | newEmailCount : Float } msg\n    emailInfo =\n        final \"emailInfo\" <|\n            cardinal .newEmailCount \"newEmailCount\" decimalStandard <|\n                { one =\n                    s \"You have one new email.\"\n                , other =\n                    [ s \"You have \"\n                    , count\n                    , s \" new emails.\"\n                    ]\n                        |> concat\n                }\n\n    type Gender\n        = Female\n        | Male\n        | Other\n\n    partyInfo : Translation { args | gender : Gender } msg\n    partyInfo =\n        final \"partyInfo\" <|\n            select .gender \"gender\" (s \"They are giving a party.\") <|\n                [ equals Female \"female\" <|\n                    s \"She is giving a party.\"\n                , equals Male \"male\" <|\n                    s \"He is giving a party.\"\n                ]\n\n    otherEmailInfo : Translation { args | newEmailCount : Float } msg\n    otherEmailInfo =\n        final \"emailInfo\" <|\n            cardinal .newEmailCount \"newEmailCount\" decimalStandard <|\n                { one =\n                    s \"You have one new email.\"\n                , other =\n                    select .newEmailCount\n                        \"newEmailCount\"\n                        (concat\n                            [ s \"You have \"\n                            , count\n                            , s \" new emails.\"\n                            ]\n                        )\n                        [ when (\\count -> count > 10000) \"alot\" <|\n                            s \"Wow, you have a lot of new emails!\"\n                        ]\n                }\n\nAnd you can use these translations in your view code like so:\n\n    import Localized exposing (print, printWith)\n    import Translations.En exposing (..)\n\n    view : String -> Int -> Gender -> Html msg\n    view name newEmailCount gender =\n        Html.div []\n            [ greeting\n                |> print\n                |> Html.text\n            , personalGreeting\n                |> printWith { name = name }\n                |> Html.text\n            , emailInfo\n                |> printWith { newEmailCount = toFloat newEmailCount }\n                |> Html.text\n            , partyInfo\n                |> printWith { gender = gender }\n                |> Html.text\n            , otherEmailInfo\n                |> printWith { newEmailCount = toFloat newEmailCount }\n                |> Html.text\n            ]\n\nIf you want to change the translations at runtime without recompiling\nyour application, you can print them in the following way:\n\n    import Localized exposing (TranslationSet, translate, translateWith, translationSet)\n    import Localized.En\n    import Translations.En exposing (..)\n\n    view : String -> Int -> Gender -> Html msg\n    view name newEmailCount gender =\n        Html.div []\n            [ greeting\n                |> translate translations\n                |> Html.text\n            , personalGreeting\n                |> translateWith translations\n                    { name = name }\n                |> Html.text\n            , emailInfo\n                |> translateWith translations\n                    { newEmailCount = toFloat newEmailCount }\n                |> Html.text\n            , partyInfo\n                |> translateWith translations\n                    { gender = gender }\n                |> Html.text\n            , otherEmailInfo\n                |> translateWith translations\n                    { newEmailCount = toFloat newEmailCount }\n                |> Html.text\n            ]\n\n    translations : TranslationSet\n    translations =\n        [ ( \"greeting\", \"Guten morgen!\" )\n        , ( \"personalGreeting\", \"Guten morgen, {name}!\" )\n        , ( \"emailInfo\"\n          , \"\"\"\n              {newEmailCount, plural,\n                one{Du hast eine neue Email.}\n                other{Du hast {newEmailCount, number} neue Emails.}\n              }\n            \"\"\"\n          )\n        , ( \"partyInfo\"\n          , \"\"\"\n              {gender, select,\n                other{Sie schmeißen eine Party.}\n                female{Sie schmeißt eine Party.}\n                male{Er schmeißt eine Party.}\n              }\n            \"\"\"\n          )\n        , ( \"otherEmailInfo\"\n          , \"\"\"\n              {newEmailCount, plural,\n                one{Du hast eine neue Email.}\n                other{{newEmailCount, select,\n                  other{Du hast {newEmailCount, number} neue Emails.}\n                  alot{Uiuiui, Du hast ganz schön viele neue Emails!}\n                }}\n              }\n            \"\"\"\n          )\n        ]\n            |> translationSet Localized.En.locale\n\nThe `translations` dictionary can of course be created at runtime by\nparsing some data.\n\n\n# Types\n\n@docs Translation, Text, final, fallback\n\n\n# Printing\n\n\n## Static\n\n@docs printWith, print, nodes\n\n\n## Dynamic\n\n@docs translateWith, translate\n\n@docs TranslationSet, translationSet, Locale, customLocale, addCardinalCases, addOrdinalCases\n\n\n# Creating Texts\n\n\n## Basic Texts\n\n@docs s, string, node\n\n\n## Combining Texts\n\n@docs concat, cons, (<>)\n\n\n## Number Formatting\n\n@docs decimal, NumberFormat, customNumberFormat\n\n\n## Pluralization\n\nEvery locale module like for example `Localized.En` exports the\npluralization texts `cardinal` and `ordinal`. You use these like this\n\n    emailInfo : Translation { args | ord : Float } msg\n    emailInfo =\n        final \"emailInfo\" <|\n            Localized.En.ordinal .ord \"ord\" Localized.En.decimalStandard <|\n                { one =\n                    [ s \"This is the \"\n                    , count\n                    , \"st message.\"\n                    ]\n                        |> concat\n                , two =\n                    [ s \"This is the \"\n                    , count\n                    , \"nd message.\"\n                    ]\n                        |> concat\n                , few =\n                    [ s \"This is the \"\n                    , count\n                    , \"rd message.\"\n                    ]\n                        |> concat\n                , other =\n                    [ s \"This is the \"\n                    , count\n                    , \"th message.\"\n                    ]\n                        |> concat\n                }\n\n@docs count, customPlural, PluralCase, AllPluralCases\n\n\n## Selects\n\n@docs select, equals, when, Case\n\n\n# Exporting\n\n@docs icuMessage, name\n\n",
    "aliases": [
      {
        "name": "AllPluralCases",
        "comment": " ",
        "args": [
          "args",
          "msg"
        ],
        "type": "{ zero : Localized.Text args msg , one : Localized.Text args msg , two : Localized.Text args msg , few : Localized.Text args msg , many : Localized.Text args msg , other : Localized.Text args msg }"
      }
    ],
    "types": [
      {
        "name": "Case",
        "comment": " ",
        "args": [
          "args",
          "msg",
          "a"
        ],
        "cases": []
      },
      {
        "name": "Locale",
        "comment": " Opaque type holding information about a locale, like for example\nwhich cardinal/ordinal plural forms are needed. Every `Localized.En`,\n... module exports a constructor for `Locale`. If you want to create\nyour custom locales, take a look at `customLocale`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "NumberFormat",
        "comment": " Opaque type representing a number formatting rule. Every locale\nmodule provides functions to create the formats which are specified in\nthe CLDR.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PluralCase",
        "comment": " This type represents the different [plural\ncases](http://www.unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules)\nwhich are used in the CLDR.\n",
        "args": [],
        "cases": [
          [
            "Zero",
            []
          ],
          [
            "One",
            []
          ],
          [
            "Two",
            []
          ],
          [
            "Few",
            []
          ],
          [
            "Many",
            []
          ],
          [
            "Other",
            []
          ]
        ]
      },
      {
        "name": "Text",
        "comment": " Opaque building block for texts.\n",
        "args": [
          "args",
          "msg"
        ],
        "cases": []
      },
      {
        "name": "Translation",
        "comment": " Opaque type which contains a piece of text which is translated into\na language. Eventually, when you want to turn a `Translation args msg`\ninto a `String` you have to provide some `args`. If you turn it into\na dom node, it may produce `msg`'s.\n",
        "args": [
          "args",
          "msg"
        ],
        "cases": []
      },
      {
        "name": "TranslationSet",
        "comment": " Opaque type holding a set of translations, which can be generated at\nruntime. If you use `translateWith` or `translate` for printing your\n`Translation`'s you will need to provide a `TranslationSet`.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "<>",
        "comment": " Infix operator version of `cons`. This lets you write\n\n    personalGreeting : Translation { args | name : String } msg\n    personalGreeting =\n        final \"personalGreeting\" <|\n            concat\n                [ s \"Hello, \"\n                , string .name \"name\"\n                , s \"!\"\n                ]\n\nas\n\n    personalGreeting : Translation { args | name : String } msg\n    personalGreeting =\n        final \"personalGreeting\"\n            (s \"Hello, \"\n                <> string .name \"name\"\n                <> s \"!\"\n            )\n\n",
        "type": "Localized.Text args msg -> Localized.Text args msg -> Localized.Text args msg"
      },
      {
        "name": "addCardinalCases",
        "comment": " Add cardinal plural forms which the locale should require.\n",
        "type": "List Localized.PluralCase -> Localized.Locale -> Localized.Locale"
      },
      {
        "name": "addOrdinalCases",
        "comment": " Add ordinal plural forms which the locale should require.\n",
        "type": "List Localized.PluralCase -> Localized.Locale -> Localized.Locale"
      },
      {
        "name": "concat",
        "comment": " Concatenate a list of texts together.\n",
        "type": "List (Localized.Text args msg) -> Localized.Text args msg"
      },
      {
        "name": "cons",
        "comment": " Concatenate two texts.\n",
        "type": "Localized.Text args msg -> Localized.Text args msg -> Localized.Text args msg"
      },
      {
        "name": "count",
        "comment": " Create a text which gets replaced by the formatted number argument\nof a pluralized text.\n\n    emailInfo : Translation { args | count : Float } msg\n    emailInfo =\n        final \"emailInfo\" <|\n            Localized.En.cardinal .count \"count\" Localized.En.decimalStandard <|\n                { one =\n                    s \"You have one new email\"\n                , other =\n                    [ s \"You have \"\n                    , count\n                    , s \" new emails\"\n                    ]\n                        |> concat\n                }\n\n",
        "type": "Localized.Text args msg"
      },
      {
        "name": "customLocale",
        "comment": " Create a custom `Locale` with minimal properties. Use functions\nlike `addCardinalCases` or `addOrdinalCases` to add further properties.\nFor example, the locale `Localized.En.locale` could have also be created\nby\n\n    en : Locale\n    en =\n        customLocale \"en\"\n            |> addCardinalCases [ One ]\n            |> addOrdinalCases [ One, Two, Few ]\n\n",
        "type": "String -> Localized.Locale"
      },
      {
        "name": "customNumberFormat",
        "comment": " Create your own number format.\n",
        "type": "(Float -> String) -> Localized.NumberFormat"
      },
      {
        "name": "customPlural",
        "comment": " Create a custom pluralized text. Use this function if you want\nto provide your own pluralization rules.\n\n**Note**: You usually want to use the `ordinal` or `cardinal` functions\nfrom one of the modules like `Localized.En`, depending on the language\nthe text is in.\n\n",
        "type": "(args -> Float) -> String -> Localized.NumberFormat -> (String -> Localized.PluralCase) -> Localized.AllPluralCases args msg -> Localized.Text args msg"
      },
      {
        "name": "decimal",
        "comment": " Create a placeholder which gets replaced by a number which is\nformatted according to the provided format.\n\n    heightInfo : Translation { args | height : Float } msg\n    heightInfo =\n        final \"heightInfo\" <|\n            concat\n                [ s \"Current height: \"\n                , decimal .height \"height\" Localized.En.decimalStandard\n                , s \".\"\n                ]\n\nThen `printWith { height = 3.1533 } heightInfo` is equal to `\"Current\nheight: 3.153.\"`.\n\n",
        "type": "(args -> Float) -> String -> Localized.NumberFormat -> Localized.Text args msg"
      },
      {
        "name": "equals",
        "comment": " Create a simple `Case` for a `select` text.\n",
        "type": "a -> String -> Localized.Text args msg -> Localized.Case args msg a"
      },
      {
        "name": "fallback",
        "comment": " Like `final` but this translation will not be exported.\n",
        "type": "String -> Localized.Text args msg -> Localized.Translation args msg"
      },
      {
        "name": "final",
        "comment": " Turn some `Text` into a `Translation` by giving it a name. This\ntranslation is `final` and will therefore be exported when you run\n\n    $ elm-intl generate-json\n\n",
        "type": "String -> Localized.Text args msg -> Localized.Translation args msg"
      },
      {
        "name": "icuMessage",
        "comment": " Export a `Translation` to the [ICU Message\nFormat](http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html).\nFor example, for the following\n\n    personalGreeting : Translation { args | name : String } msg\n    personalGreeting =\n        final \"personalGreeting\" <|\n            concat\n                [ s \"Hello, \"\n                , string .name \"name\"\n                , s \"!\"\n                ]\n\nwe have that `icuMessage personalGreeting` is equal to `\"Hello,\n{name}!\"`.\n\n",
        "type": "Localized.Translation args msg -> String"
      },
      {
        "name": "name",
        "comment": " Return the name of a translation. So `name (final \"greeting\" (s\n\"Hello!\"))` is equal to `\"greeting\"`.\n",
        "type": "Localized.Translation args msg -> String"
      },
      {
        "name": "node",
        "comment": " Create a text which eventually gets replaced by a dom node.\n\n    documentationInfo : Translation { args | link : List (Html msg) -> Html msg } msg\n    documentationInfo =\n        final \"documentationInfo\" <|\n            concat\n                [ s \"Take a look at our \"\n                , node .link \"link\" <|\n                    s \"documentation\"\n                , \".\"\n                ]\n\n    view : String -> Html msg\n    view url =\n        Html.div [] <|\n            nodes { link = Html.a [ Html.Attributes.href url ] }\n                documentationInfo\n\nThen `view` is equivalent to\n\n    view : String -> Html msg\n    view url =\n        Html.div []\n            [ Html.text \"Take a look at our \"\n            , Html.a [ Html.Attributes.href url ]\n                [ Html.text \"documentation\" ]\n            , Html.text \".\"\n            ]\n\n",
        "type": "(args -> List (VirtualDom.Node msg) -> VirtualDom.Node msg) -> String -> Localized.Text args msg -> Localized.Text args msg"
      },
      {
        "name": "nodes",
        "comment": " Use this function to turn a `Translation` into a list of dom nodes.\nYou want to do this if one of the `Text`s is a `node`.\n\n    documentationInfo : Translation { args | link : List (Html msg) -> Html msg } msg\n    documentationInfo =\n        final \"documentationInfo\" <|\n            concat\n                [ s \"Take a look at our \"\n                , node .link \"link\" <|\n                    s \"documentation\"\n                , \".\"\n                ]\n\n    view : String -> Html msg\n    view url =\n        Html.div [] <|\n            nodes { link = Html.a [ Html.Attributes.href url ] }\n                documentationInfo\n\nThen `view` is equivalent to\n\n    view : String -> Html msg\n    view url =\n        Html.div []\n            [ Html.text \"Take a look at our \"\n            , Html.a [ Html.Attributes.href url ]\n                [ Html.text \"documentation\" ]\n            , Html.text \".\"\n            ]\n\n",
        "type": "args -> Localized.Translation args msg -> List (VirtualDom.Node msg)"
      },
      {
        "name": "print",
        "comment": " Use this function if your `Translation` does not need arguments.\nThis is basically `print translation = printWith {} translation`.\n",
        "type": "Localized.Translation {} msg -> String"
      },
      {
        "name": "printWith",
        "comment": " Use this function to turn a `Translation` into a `String`.\n\n    greeting : String\n    greeting =\n        printWith { name = \"Alice\" } <|\n            final \"greeting\" <|\n                concat <|\n                    [ s \"Good morning, \"\n                    , string .name \"name\"\n                    , s \"!\"\n                    ]\n\nThen `greeting` is equal to `\"Good morning, Alice!\"`.\n\n",
        "type": "args -> Localized.Translation args msg -> String"
      },
      {
        "name": "s",
        "comment": " Create a text that simply returns the given `String`.\n\n    greeting : Translation {} msg\n    greeting =\n        final \"greeting\" <|\n            s \"Hello!\"\n\nThen `print greeting` is equal to `\"Hello!\"`.\n\n",
        "type": "String -> Localized.Text args msg"
      },
      {
        "name": "select",
        "comment": " Create a text which selects between different versions using the\nprovided function. You have to provide a default (`other`) text and\na list of `Case`s.\n\n    partyInfo : Translation { args | gender : Gender } msg\n    partyInfo =\n        select .gender \"gender\" (s \"They give a party.\") <|\n            [ equals Female \"female\" <|\n                s \"She gives a party.\"\n            , equals Male \"male\" <|\n                s \"He gives a party.\"\n            ]\n\n    type Gender\n        = Female\n        | Male\n        | Other\n\n",
        "type": "(args -> a) -> String -> Localized.Text args msg -> List (Localized.Case args msg a) -> Localized.Text args msg"
      },
      {
        "name": "string",
        "comment": " Create a placeholder which eventually gets replaced by a `String`\nwhich is provided at runtime.\n\n    personalGreeting : Translation { args | name : String } msg\n    personalGreeting =\n        final \"personalGreeting\" <|\n            concat\n                [ s \"Hello, \"\n                , string .name \"name\"\n                , s \"!\"\n                ]\n\nThen `printWith { name = \"Alice\" } personalGreeting` is equal to\n`\"Hello, Alice!\"`.\n\n",
        "type": "(args -> String) -> String -> Localized.Text args msg"
      },
      {
        "name": "translate",
        "comment": " Convenience function if the `Translation` does not need arguments.\n",
        "type": "Localized.TranslationSet -> Localized.Translation {} msg -> String"
      },
      {
        "name": "translateWith",
        "comment": " Use this function if you want to replace a `Translation` at runtime\nwith new content. It will use the name of the `Translation` to fetch the\nnew content from the `TranslationSet`. This content should be in the\n[ICU Message\nFormat](http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html).\n\n    greeting : String\n    greeting =\n        final \"greeting\" <|\n            concat <|\n                [ s \"Good morning, \"\n                , string .name \"name\"\n                , s \"!\"\n                ]\n\n    output : String -> String\n    output name =\n        greeting\n            |> translateWith translations\n                { name = name }\n\n    translations : TranslationSet\n    translations =\n        [ ( \"greeting\", \"Guten morgen, {name}!\" )\n        ]\n            |> translationSet Localized.En.locale\n\nThen `greeting \"Alice\"` is equal to `\"Guten morgen, Alice!\"`.\n\n",
        "type": "Localized.TranslationSet -> args -> Localized.Translation args msg -> String"
      },
      {
        "name": "translationSet",
        "comment": " Create a `TranslationSet` by providing a `Locale` and a list of\ntranslations. The first `String` is the name of the `Translation`, the\nsecond is the content which should be in the [ICU Message\nFormat](http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html)\n",
        "type": "Localized.Locale -> List ( String, String ) -> Localized.TranslationSet"
      },
      {
        "name": "when",
        "comment": " Create a custom `Case` which gets choosen if the predicate is true.\n",
        "type": "(a -> Bool) -> String -> Localized.Text args msg -> Localized.Case args msg a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]